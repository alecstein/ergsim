<!doctype html>
<html>

<head>
  <meta charset="UTF-8\" />
  <script src="webui.js"></script>
  <script src="https://d3js.org/d3.v6.js"></script>
  <title>ideal gas and piston simulation</title>
</head>

<body>
  Gas
  <div id="density"></div>
  Momentum
  <div id="momentum"></div>
  <script>
    function rawBytesToCounts(byteArray) {
      const unpaddedBytes = byteArray.slice(6, -1);
      const uint8Array = new Uint8Array(unpaddedBytes);
      const buffer = uint8Array.buffer;
      const dataView = new DataView(buffer);
      const numInts = buffer.byteLength / 4; // Each U32 integer is 4 bytes
      let data = [];
      for (let i = 0; i < numInts; i++) {
        data[i] = dataView.getUint32(i * 4, true); // Read 32-bit integers
      }
      return data;
    }

    var margin = { top: 50, right: 30, bottom: 30, left: 40 };
    var width = 800 - margin.left - margin.right;
    var height = 300 - margin.top - margin.bottom;

    var N = undefined;
    var xMax = 1.5;
    var vMax = undefined;
    var mu = undefined;
    // vy = d3.scaleLinear().domain([0, 100]).range([height, 0]);


    function setConstants(n, mu_) {
      N = n;

      vMax = Math.sqrt(mu_)*0.05;
      mu = mu_;

      v = d3.scaleLinear().domain([-vMax, vMax]).range([0, width]);
      x = d3.scaleLinear().domain([0, xMax]).range([0, width]);
      vy = d3.scaleLinear().domain([0, 1.5 * rho(0, mu, N)]).range([height, 0]);

      d3.select("#density > svg:nth-child(1) > g:nth-child(1) > text:nth-child(2)")
        .text("gas density (particle density) along x-axis, " + N + " particles");

      drawMomentumPrediction(mu, vMax);
    };

    function rho(p, mu, N) {
      const part1 = 1 / (Math.sqrt(Math.PI * mu));
      const part2 = Math.sqrt((3 * N + 1) / 2);
      const part3 = (1 - Math.pow(p, 2) / mu);
      const part4 = Math.pow(part3, 3 * N / 2);

      return part1 * part2 * part4;
    }

    function drawMomentumPrediction(mu, vMax) {
      var numPoints = 1000;

      var lineData = Array.from({ length: numPoints }, (_, i) => {
        var vVal = -vMax + (i / numPoints) * (2 * vMax); // scale i to [-vMax, vMax]
        var y = rho(vVal, mu, N); // Normalized Gaussian function
        return { v: vVal, y: y };
      });

      var line = d3.line()
        .x(function (d) { return v(d.v); })
        .y(function (d) { return vy(d.y); });

      d3.select("#momentum > svg > g")
        .append("path")
        .datum(lineData)
        .attr("fill", "none")
        .attr("stroke", "blue")
        .attr("stroke-width", 2)
        .attr("d", line);

      var areaUnderLine = 0;
      for (let i = 0; i < lineData.length - 1; i++) {
        let base1 = lineData[i].y;
        let base2 = lineData[i + 1].y;
        let height = lineData[i + 1].v - lineData[i].v;
        areaUnderLine += 0.5 * (base1 + base2) * height;
      }

    };



    function initDensityHist() {
      x = d3.scaleLinear().domain([0, xMax]).range([0, width]);

      var svg = d3
        .select("#density")
        .append("svg")
        .attr("width", width + margin.left + margin.right)
        .attr("height", height + margin.top + margin.bottom)
        .append("g")
        .attr("transform", "translate(" + margin.left + "," + margin.top + ")");


      svg
        .append("g")
        .attr("transform", "translate(0," + height + ")")
        .call(d3.axisBottom(x))
        .call((g) =>
          g
            .append("text")
            .attr("x", width)
            .attr("y", margin.bottom - 4)
            .attr("fill", "currentColor")
            .attr("text-anchor", "end")
            .text("x")
        );
    }

    initDensityHist();

    function updateDensityHist(bytes) {

      var svg = d3.select("#density svg g");

      var data = rawBytesToCounts(bytes);
      const nBins = data.length;
      var binWidth = xMax / nBins;
      var x = d3.scaleLinear().domain([0, xMax]).range([0, width]);
      var colorScale = d3.scaleLinear().domain([0, N / 50]).range(["white", "orange"]);

      // Bind the data to the rects
      var rects = svg.selectAll("rect")
        .data(data);

      // Enter selection: Add new rects for new data
      rects.enter().append("rect")
        // .attr("x", 1)
        .attr("width", x(binWidth) - x(0)) // Width of each bin
        .attr("height", height) // Constant height for all bins
        .merge(rects) // Merge enter and update selections
        .attr("transform", function (d, i) {
          return "translate(" + x(i * binWidth) + ",0)";
        })
        .style("fill", function (d) {
          return colorScale(d);
        });

      // Exit selection: Remove rects that are no longer needed
      // rects.exit().remove();
    }

    function initMomentumHistogram() {

      v = d3.scaleLinear().domain([-vMax, vMax]).range([0, width]);

      var svg = d3
        .select("#momentum")
        .append("svg")
        .attr("width", width + margin.left + margin.right)
        .attr("height", height + margin.top + margin.bottom)
        .append("g")
        .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

      vy = d3.scaleLinear().domain([0, 1.5 * rho(0, mu, N)]).range([height, 0]);

      svg.append("g")
        .attr("class", "y-axis")
        .call(d3.axisLeft(vy));


      svg
        .append("g")
        .attr("class", "x-axis")
        .attr("transform", "translate(0," + height + ")")
        .call(d3.axisBottom(v))
        .call((g) =>
          g
            .append("text")
            // .attr("x", width)
            .attr("y", margin.bottom - 4)
            .attr("fill", "currentColor")
            .attr("text-anchor", "end")
            .text("p")
        );
    }

    initMomentumHistogram()

    function updateMomentumHist(bytes) {
      var svg = d3.select("#momentum svg g");

      var data = rawBytesToCounts(bytes);
      const nBins = data.length;
      var binWidth = 2 * vMax / nBins;
      var totalArea = N * 2 * vMax / nBins;
      var normalizedData = data.map((d) => d / totalArea);

      svg.select(".y-axis").call(d3.axisLeft(vy));
      svg.select(".x-axis").call(d3.axisBottom(v));

      var areaUnderHistogram = 0;
      var binWidth = 2 * vMax / nBins; // Width of each bin
      normalizedData.forEach(d => {
        areaUnderHistogram += d * binWidth;
      });

      var rects = svg.selectAll("rect")
        .data(normalizedData);

      // Enter selection: Create new rects for new data
      rects.enter().append("rect")
        .attr("width", v(binWidth) - v(0))// Width of each bin
        // .style("fill", "black ")
        // Set initial attributes for new rects here (if necessary)
        .merge(rects) // Merge enter and update selections
        // .attr("v", 1)
        .attr("transform", function (d, i) {
          return "translate(" + v(i * binWidth - vMax) + ",0)";
        })
        .attr("y", function (d) { return vy(d); })
        .attr("height", function (d) { return height - vy(d); });

      // Exit selection: Remove rects that are no longer needed
      // rects.exit().remove();

      svg.select("#momentum > svg > g > path")
        .raise();

      // drawMomentumPrediction(mu, vMax);
    }



  </script>
</body>

</html>